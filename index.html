<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Maximum Houses Near Road ‚Äî Parametrizable Field</title>
<style>
  :root {
    --cell: 44px;
    --gap: 5px;
    --road: #2d3748;
    --house: #16a34a;
    --covered: #93c5fd22;
    --gridline: #33415566;
    --bg: #0b1020;
    --card: #0f172a;
    --text: #e5e7eb;
    --muted: #94a3b8;
    --accent: #60a5fa;
  }
  * { box-sizing: border-box }
  body {
    margin: 0; background: radial-gradient(1200px 700px at 20% -20%, #172554 0%, #0b1020 60%, #050816 100%);
    color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans";
    min-height: 100vh; display: grid; place-items: start center; padding: 20px;
  }
  .app { width: min(1100px, 96vw); display: grid; gap: 14px }
  .panel {
    background: linear-gradient(180deg, #0a1220, #060d1a);
    border: 1px solid #172036; border-radius: 16px; padding: 14px;
    box-shadow: 0 14px 28px rgba(2,8,23,.35), inset 0 1px 0 rgba(255,255,255,.03);
  }
  .header { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; justify-content: space-between }
  .title { font-weight: 800; letter-spacing:.2px; display:flex; align-items:center; gap:10px }
  .title .dot { width:10px;height:10px;border-radius:50%;background:var(--accent);box-shadow:0 0 10px var(--accent)}
  .controls { display:flex; flex-wrap:wrap; gap:8px; align-items:center }
  label { font-size: 14px; color: var(--muted) }
  input[type="number"] { width: 64px; padding: 8px; border-radius: 10px; border:1px solid #1f2b44; background:#0b1324; color:var(--text) }
  button {
    background: linear-gradient(180deg, #1f2937, #0b1324);
    color: var(--text); border: 1px solid #334155; padding: 10px 14px; border-radius: 12px;
    font-weight: 700; letter-spacing: .2px; cursor: pointer;
    transition: transform .05s ease, box-shadow .2s ease, border-color .2s ease;
    box-shadow: 0 10px 20px rgba(2,8,23,.25), inset 0 0 0 0 rgba(255,255,255,.05);
  }
  button:hover { border-color: #60a5faaa; box-shadow: 0 12px 24px rgba(2,8,23,.35), inset 0 1px 0 0 rgba(255,255,255,.06) }
  button:active { transform: translateY(1px) }
  button:disabled { 
    opacity: 0.5; 
    cursor: not-allowed; 
    background: linear-gradient(180deg, #374151, #1f2937); 
    border-color: #4b5563; 
  }
  button:disabled:hover { 
    border-color: #4b5563; 
    box-shadow: 0 10px 20px rgba(2,8,23,.25), inset 0 0 0 0 rgba(255,255,255,.05); 
    transform: none; 
  }
  .primary { background: linear-gradient(180deg, #2563eb, #1d4ed8); border-color:#3b82f6 }
  .danger { background: linear-gradient(180deg, #b91c1c, #7f1d1d); border-color:#ef4444 }
  .muted { opacity:.85 }
  .legend { display:flex; gap:14px; align-items:center; color:var(--muted); font-size:14px }
  .dotbox { display:inline-flex; gap:6px; align-items:center }
  .dotbox .dot { width:12px; height:12px; border-radius:4px; outline:1px solid #3a4a66 }
  .dot-road { background: var(--road) }
  .dot-house { background: #16a34a }
  .dot-free { background: #a1a1aa }
  .wrap { display:grid; gap: 12px }
  .grid-wrap { background: linear-gradient(180deg, #0b1020, #050816); border:1px solid #172036; border-radius: 16px; padding: 16px; overflow:auto }
  .grid {
    display: grid;
    gap: 0;
    justify-content: center;
  }
  .cell {
    width: var(--cell); height: var(--cell); border-radius: 0; background: #a1a1aa;
    position: relative; overflow: hidden; isolation: isolate;
    cursor: pointer; transition: box-shadow 0.2s ease;
  }

  .cell.clickable-add:hover {
    box-shadow: inset 0 0 15px rgba(255, 255, 255, 0.9);
  }
  .cell.clickable-remove:hover {
    box-shadow: inset 0 0 10px rgba(239, 68, 68, 0.8);
  }
  .cell .coord { display:none }
  .cell.road { 
    background: #16a34a;
    position: relative;
  }
  .cell.house { 
    background: #16a34a; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    font-size: 32px;
  }
  .cell.house::before { content: 'üè†'; }
  .cell .covered { position:absolute; inset:0; background: var(--covered); pointer-events:none; opacity:0; transition: opacity .15s ease }
  .cell.covered-on .covered { opacity: 1 }
  .stats { display:grid; grid-template-columns: repeat(3, minmax(0,1fr)); gap:10px }
  .stat { background: linear-gradient(180deg, #0a1220, #060d1a); border:1px solid #172036; border-radius: 14px; padding: 10px 12px; text-align:center }
  .stat .n { font-size:22px; font-weight:800; color:#f8fafc }
  .stat .t { font-size:12px; color:var(--muted); margin-top:4px; letter-spacing:.2px }
  .footnote { color:var(--muted); font-size:13px; text-align:center; margin-top: 4px }
  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap }
  .progress { color:var(--muted); font-size:13px }
  .sep { width:1px; height:20px; background:#23304a; margin:0 6px }
  .desc { color:var(--muted); font-size:14px; line-height:1.5; margin-top:12px }
  .desc em { color:var(--text); font-style:italic }
  .desc code { background:#1a2332; color:#94d3a2; padding:2px 6px; border-radius:4px; font-family:ui-monospace,monospace }
</style>
</head>
<body>
  <div class="app">
    <div class="panel header">
      <div class="title"><span class="dot"></span>Maximum Houses Near Road</div>
      <div class="controls">
        <label>Width <input id="w" type="number" min="2" max="15" value="7"></label>
        <label>Height <input id="h" type="number" min="2" max="15" value="7"></label>
        <button id="resize">Reset</button>
        <span class="sep"></span>
        <button id="solveHeuristic" class="primary">Heuristic Solve</button>
        <button id="stopHeuristic" class="danger">Stop</button>
        <button id="solveExact" class="primary">Solve Exactly</button>
        <button id="stopExact" class="danger">Stop</button>
      </div>
      <div class="desc">
        Grid <em>W √ó H</em>, starting road cell is <code>(0,0)</code>. You can extend the road up/down/left/right only (no diagonals) and the road must remain 4-connected.
        A house can be placed in any cell that shares a side with at least one road cell (no diagonals), and houses cannot overlap road.
        <br>
        <b>The goal is to build a road shape that maximizes houses while minimizing road length (weighted objective: houses - 0.2 √ó road length).</b>
        <br>
        <b>Manual drawing:</b> Click adjacent empty cells to extend the road, or click road cells to remove them (if it doesn't break connectivity).
        This tool lets you build the road manually or compute an optimal solution. Coverage (cells at distance 1 from the road) is always shown.
      </div>
    </div>

    <div class="panel wrap">
      <div class="legend">
        <span class="dotbox"><span class="dot dot-road"></span> road</span>
        <span class="dotbox"><span class="dot dot-house"></span> house</span>
        <span class="dotbox"><span class="dot dot-free"></span> empty</span>
        <span class="sep"></span>
        <span class="progress" id="progress">Ready.</span>
      </div>
      <div class="grid-wrap">
        <div id="grid" class="grid"></div>
      </div>
      <div class="stats">
        <div class="stat"><div class="n" id="housesCount">0</div><div class="t">houses</div></div>
        <div class="stat"><div class="n" id="roadLen">0</div><div class="t">road length</div></div>
        <div class="stat"><div class="n" id="coverPct">0%</div><div class="t">cell coverage</div></div>
      </div>
      <div class="footnote">
        Start at (0,0). Road is connected (4-neighborhood). House in cell adjacent to road.
      </div>
    </div>
  </div>

<script>
(() => {
  // ========= Utility / Bitset =========
  const bit = i => (1n << BigInt(i));
  const has = (B,i) => (B & bit(i)) !== 0n;
  const add = (B,i) => (B | bit(i));
  const popcnt = (B) => {
    let x=B, c=0; while (x) { x &= (x-1n); c++; } return c;
  };

  // ========= State (dynamic by size) =========
  let W = 7, H = 7, N = W*H;
  let allNeigh = [];
  let id = (r,c)=> r*W + c;
  let rc = (i)=> [Math.floor(i/W), i%W];
  const inside = (r,c)=> r>=0 && c>=0 && r<H && c<W;

  function buildNeigh() {
    N = W*H;
    id = (r,c)=> r*W + c;
    rc = (i)=> [Math.floor(i/W), i%W];
    allNeigh = Array.from({length:N}, (_,i)=>{
      const [r,c] = rc(i);
      const ns = [];
      if (inside(r-1,c)) ns.push(id(r-1,c));
      if (inside(r+1,c)) ns.push(id(r+1,c));
      if (inside(r,c-1)) ns.push(id(r,c-1));
      if (inside(r,c+1)) ns.push(id(r,c+1));
      return ns;
    });
  }

  // ========= Core helpers =========
  function computeCovered(roads) {
    let coveredMask = 0n;
    for (let i=0;i<N;i++) if (has(roads,i)) {
      const ns = allNeigh[i];
      for (let k=0;k<ns.length;k++) coveredMask |= bit(ns[k]);
    }
    const housesMask = coveredMask & ~roads;
    return { coveredMask, housesMask };
  }
  function frontier(roads) {
    let F = 0n;
    for (let i=0;i<N;i++) if (has(roads,i)) {
      const ns = allNeigh[i];
      for (let k=0;k<ns.length;k++) {
        const v = ns[k];
        if (!has(roads, v)) F |= bit(v);
      }
    }
    return F;
  }
  function kGain(cell, coveredMask) {
    // New houses (upper-bounded) if we add road at `cell`: neighbors newly covered minus 1 (since frontier cell already covered)
    const ns = allNeigh[cell];
    let k=0;
    for (let t=0;t<ns.length;t++) if ((coveredMask & bit(ns[t]))===0n) k++;
    return k-1;
  }
  function applyAdd(roads, coveredMask, cell) {
    let newRoads = add(roads, cell);
    let newCovered = coveredMask;
    const ns = allNeigh[cell];
    for (let t=0;t<ns.length;t++) newCovered |= bit(ns[t]);
    return [newRoads, newCovered];
  }

  // ========= Heuristic: Beam + Lookahead + Restarts =========
  function heuristicSolve(roads0, covered0, opts={beam:40, restarts:8, lookahead:5}) {
    const { beam, restarts, lookahead } = opts;
    let best = { roads: roads0, covered: covered0 };
    let bestH = popcnt((covered0 & ~roads0));
    function houses(roads, covered){ return popcnt((covered & ~roads)); }

    function lookaheadOnce(roads, covered, depth) {
      if (depth===0) return {gain:0, path:[]};
      const base = houses(roads, covered);
      const F = frontier(roads);
      if (F===0n) return {gain:0, path:[]};
      // candidates sorted by delta desc and distance to center
      const center = [Math.floor(H/2), Math.floor(W/2)];
      const cand = [];
      for (let i=0;i<N;i++) if ((F & bit(i))!==0n) {
        const delta = kGain(i, covered);
        const [r,c] = rc(i); const d = Math.abs(r-center[0])+Math.abs(c-center[1]);
        cand.push({i, delta, d});
      }
      cand.sort((a,b)=> (b.delta - a.delta) || (a.d - b.d));
      const lim = Math.min(8, cand.length);
      let bestLocal = {gain:-1e9, path:[]};
      for (let j=0;j<lim;j++) {
        const v = cand[j].i;
        const [nr,nc] = applyAdd(roads, covered, v);
        const g0 = houses(nr,nc) - base;
        const sub = lookaheadOnce(nr,nc, depth-1);
        const total = g0 + sub.gain;
        if (total > bestLocal.gain) bestLocal = {gain: total, path: [v, ...sub.path]};
      }
      if (bestLocal.gain<=0) return {gain:0, path:[]};
      return bestLocal;
    }

    for (let rep=0; rep<restarts; rep++) {
      let beamStates = [{roads: roads0, covered: covered0}];
      let improved = true;
      while (improved) {
        improved = false;
        // collect expansions
        const pool = [];
        for (const st of beamStates) {
          const F = frontier(st.roads);
          if (F===0n) continue;
          const candidates = [];
          for (let i=0;i<N;i++) if ((F & bit(i))!==0n) {
            const delta = kGain(i, st.covered);
            candidates.push({i, delta});
          }
          // keep top few + a bit of randomness
          candidates.sort((a,b)=> b.delta - a.delta);
          const keep = Math.min(12, candidates.length);
          for (let j=0;j<keep;j++) {
            const {i, delta} = candidates[j];
            const [nr, nc] = applyAdd(st.roads, st.covered, i);
            const h = houses(nr, nc);
            pool.push({roads: nr, covered: nc, score: h*10 + delta}); // bias by delta to spread
          }
          // small random exploration if no positive delta
          if (keep===0 || candidates[0].delta <= 0) {
            let extra = 0, tries = 0;
            while (extra < 4 && tries < 20 && candidates.length) {
              const p = candidates[Math.floor(Math.random()*candidates.length)].i;
              const [nr, nc] = applyAdd(st.roads, st.covered, p);
              const h = houses(nr, nc);
              pool.push({roads: nr, covered: nc, score: h*10 - 5});
              extra++; tries++;
            }
          }
        }
        if (pool.length===0) break;
        // Beam selection
        pool.sort((a,b)=> b.score - a.score);
        // dedup by roads mask string
        const next = [];
        const seen = new Set();
        for (const p of pool) {
          const key = p.roads.toString();
          if (seen.has(key)) continue;
          seen.add(key);
          next.push({roads:p.roads, covered:p.covered});
          if (next.length >= beam) break;
        }
        beamStates = next;
        // local lookahead to squeeze a bit
        const refined = [];
        for (const st of beamStates) {
          const plan = lookaheadOnce(st.roads, st.covered, lookahead);
          let roads = st.roads, covered = st.covered;
          if (plan.path.length) {
            for (const step of plan.path) {
              [roads, covered] = applyAdd(roads, covered, step);
            }
          }
          refined.push({roads, covered});
        }
        // evaluate and keep best
        for (const st of refined) {
          const h = houses(st.roads, st.covered);
          if (h > bestH) { bestH = h; best = st; improved = true; }
        }
        beamStates = refined;
      }
    }
    return { roads: best.roads, coveredMask: best.covered, houses: bestH };
  }

  // ========= Web Workers =========
  let exactWorker = null;
  let heuristicWorker = null;

  // ========= Solver State Management =========
  function setSolverButtons(heuristicRunning, exactRunning) {
    // Disable/enable solve buttons based on running state
    document.getElementById('solveHeuristic').disabled = heuristicRunning || exactRunning;
    document.getElementById('solveExact').disabled = heuristicRunning || exactRunning;
    
    // Enable/disable stop buttons based on running state
    document.getElementById('stopHeuristic').disabled = !heuristicRunning;
    document.getElementById('stopExact').disabled = !exactRunning;
  }

  // ========= Heuristic solver (Web Worker) =========
  function startHeuristicSolver(roads0, covered0, opts = {beam: 40, restarts: 8, lookahead: 5}) {
    stopHeuristicSolver(); // ensure single worker
    setSolverButtons(true, false); // heuristic running
    const code = `
      let W, H, N, allNeigh;
      const bit = i => (1n << BigInt(i));
      const has = (B,i) => (B & bit(i)) !== 0n;
      const add = (B,i) => (B | bit(i));
      const popcnt = (B) => {
        let x=B, c=0; while (x) { x &= (x-1n); c++; } return c;
      };
      const rc = (i)=> [Math.floor(i/W), i%W];

      function frontier(roads) {
        let F = 0n;
        for (let i=0;i<N;i++) if (has(roads,i)) {
          const ns = allNeigh[i];
          for (let k=0;k<ns.length;k++) {
            const v = ns[k];
            if (!has(roads, v)) F |= bit(v);
          }
        }
        return F;
      }
      function kGain(cell, coveredMask) {
        const ns = allNeigh[cell];
        let k=0;
        for (let t=0;t<ns.length;t++) if ((coveredMask & bit(ns[t]))===0n) k++;
        return k-1;
      }
      function applyAdd(roads, coveredMask, cell) {
        let newRoads = add(roads, cell);
        let newCovered = coveredMask;
        const ns = allNeigh[cell];
        for (let t=0;t<ns.length;t++) newCovered |= bit(ns[t]);
        return [newRoads, newCovered];
      }

      let cancelled = false;
      onmessage = (e)=>{
        const msg = e.data;
        if (msg?.cmd === 'cancel') { cancelled = true; return; }
        if (msg?.cmd === 'solve') {
          cancelled = false;
          W=msg.W; H=msg.H; N=W*H; allNeigh = msg.allNeigh;
          const { beam, restarts, lookahead } = msg.opts;
          
          let roads0 = BigInt(msg.roads);
          let covered0 = BigInt(msg.covered);
          let best = { roads: roads0, covered: covered0 };
          let bestH = popcnt((covered0 & ~roads0));
          let bestRoadLen = popcnt(roads0);
          let bestObj = bestH - 0.2 * bestRoadLen;
          function houses(roads, covered){ return popcnt((covered & ~roads)); }

          function lookaheadOnce(roads, covered, depth) {
            if (depth===0) return {gain:0, path:[]};
            const base = houses(roads, covered);
            const F = frontier(roads);
            if (F===0n) return {gain:0, path:[]};
            const center = [Math.floor(H/2), Math.floor(W/2)];
            const cand = [];
            for (let i=0;i<N;i++) if ((F & bit(i))!==0n) {
              const delta = kGain(i, covered);
              const [r,c] = rc(i); const d = Math.abs(r-center[0])+Math.abs(c-center[1]);
              cand.push({i, delta, d});
            }
            cand.sort((a,b)=> (b.delta - a.delta) || (a.d - b.d));
            const lim = Math.min(8, cand.length);
            let bestLocal = {gain:-1e9, path:[]};
            for (let j=0;j<lim;j++) {
              const v = cand[j].i;
              const [nr,nc] = applyAdd(roads, covered, v);
              const g0 = houses(nr,nc) - base;
              const sub = lookaheadOnce(nr,nc, depth-1);
              const total = g0 + sub.gain;
              if (total > bestLocal.gain) bestLocal = {gain: total, path: [v, ...sub.path]};
            }
            if (bestLocal.gain<=0) return {gain:0, path:[]};
            return bestLocal;
          }

          const start = Date.now();
          let lastPing = start;

          for (let rep=0; rep<restarts && !cancelled; rep++) {
            postMessage({type:'progress', rep, restarts, bestH});
            
            let beamStates = [{roads: roads0, covered: covered0}];
            let improved = true;
            while (improved && !cancelled) {
              improved = false;
              const pool = [];
              for (const st of beamStates) {
                const F = frontier(st.roads);
                if (F===0n) continue;
                const candidates = [];
                for (let i=0;i<N;i++) if ((F & bit(i))!==0n) {
                  const delta = kGain(i, st.covered);
                  candidates.push({i, delta});
                }
                candidates.sort((a,b)=> b.delta - a.delta);
                const keep = Math.min(12, candidates.length);
                for (let j=0;j<keep;j++) {
                  const {i, delta} = candidates[j];
                  const [nr, nc] = applyAdd(st.roads, st.covered, i);
                  const h = houses(nr, nc);
                  pool.push({roads: nr, covered: nc, score: h*10 + delta});
                }
                if (keep===0 || candidates[0].delta <= 0) {
                  let extra = 0, tries = 0;
                  while (extra < 4 && tries < 20 && candidates.length) {
                    const p = candidates[Math.floor(Math.random()*candidates.length)].i;
                    const [nr, nc] = applyAdd(st.roads, st.covered, p);
                    const h = houses(nr, nc);
                    pool.push({roads: nr, covered: nc, score: h*10 - 5});
                    extra++; tries++;
                  }
                }
              }
              if (pool.length===0) break;
              pool.sort((a,b)=> b.score - a.score);
              const next = [];
              const seen = new Set();
              for (const p of pool) {
                const key = p.roads.toString();
                if (seen.has(key)) continue;
                seen.add(key);
                next.push({roads:p.roads, covered:p.covered});
                if (next.length >= beam) break;
              }
              beamStates = next;
              const refined = [];
              for (const st of beamStates) {
                const plan = lookaheadOnce(st.roads, st.covered, lookahead);
                let roads = st.roads, covered = st.covered;
                if (plan.path.length) {
                  for (const step of plan.path) {
                    [roads, covered] = applyAdd(roads, covered, step);
                  }
                }
                refined.push({roads, covered});
              }
              for (const st of refined) {
                const h = houses(st.roads, st.covered);
                const roadLen = popcnt(st.roads);
                const obj = h - 0.2 * roadLen;
                if (obj > bestObj) { 
                  bestH = h; 
                  bestRoadLen = roadLen;
                  bestObj = obj;
                  best = st; 
                  improved = true; 
                  postMessage({type:'improvement', bestH, bestObj: bestObj.toFixed(1), bestRoadLen, bestRoads: best.roads.toString(), bestCovered: best.covered.toString()});
                }
              }
              beamStates = refined;

              const now = Date.now();
              if (now - lastPing > 300) {
                postMessage({type:'progress', rep, restarts, bestH});
                lastPing = now;
              }
            }
          }

          if (cancelled) {
            postMessage({type:'cancelled', bestH, bestObj: bestObj.toFixed(1), bestRoadLen, bestRoads: best.roads.toString(), bestCovered: best.covered.toString()});
          } else {
            postMessage({type:'done', bestH, bestObj: bestObj.toFixed(1), bestRoadLen, bestRoads: best.roads.toString(), bestCovered: best.covered.toString(), ms: Date.now()-start});
          }
        }
      };
    `;
    const blob = new Blob([code], {type: 'application/javascript'});
    const url = URL.createObjectURL(blob);
    heuristicWorker = new Worker(url);

    heuristicWorker.onmessage = (e) => {
      const data = e.data;
      if (data.type === 'progress') {
        progressEl.textContent = `Heuristic search‚Ä¶ restart ${data.rep + 1}/${data.restarts}, houses: ${data.bestH}, road: ${data.bestRoadLen || 'N/A'}, obj: ${data.bestObj || 'N/A'}`;
      } else if (data.type === 'improvement') {
        progressEl.textContent = `Heuristic search‚Ä¶ found better: houses: ${data.bestH}, road: ${data.bestRoadLen}, obj: ${data.bestObj}`;
        tryUpdateFromHeuristicWorker(data.bestRoads, data.bestCovered);
      } else if (data.type === 'done') {
        progressEl.textContent = `Heuristic completed in ${data.ms} ms. Houses: ${data.bestH}, road: ${data.bestRoadLen}, obj: ${data.bestObj}`;
        tryUpdateFromHeuristicWorker(data.bestRoads, data.bestCovered, true);
        URL.revokeObjectURL(url);
        setSolverButtons(false, false); // no solvers running
      } else if (data.type === 'cancelled') {
        progressEl.textContent = `Heuristic stopped. Houses: ${data.bestH}, road: ${data.bestRoadLen}, obj: ${data.bestObj}`;
        tryUpdateFromHeuristicWorker(data.bestRoads, data.bestCovered);
        URL.revokeObjectURL(url);
        setSolverButtons(false, false); // no solvers running
      }
    };

    const payload = {
      cmd: 'solve',
      W, H, allNeigh,
      roads: roads0.toString(),
      covered: covered0.toString(),
      opts
    };
    heuristicWorker.postMessage(payload);
  }

  function stopHeuristicSolver() {
    if (heuristicWorker) { 
      heuristicWorker.postMessage({cmd:'cancel'}); 
      heuristicWorker.terminate(); 
      heuristicWorker = null; 
    }
    setSolverButtons(false, false); // no solvers running
  }

  function tryUpdateFromHeuristicWorker(roadsStr, coveredStr, final=false) {
    const roads = BigInt(roadsStr), covered = BigInt(coveredStr);
    state.roads = roads; 
    state.coveredMask = covered;
    render();
  }

  // ========= Exact solver (Web Worker) =========
  function startExactSolver(roads0, covered0) {
    stopExactSolver(); // ensure single worker
    setSolverButtons(false, true); // exact running
    const code = `
      let W, H, N, allNeigh;
      const bit = i => (1n << BigInt(i));
      const has = (B,i) => (B & bit(i)) !== 0n;
      const add = (B,i) => (B | bit(i));
      const popcnt = (B)=>{ let x=B,c=0; while(x){ x&=(x-1n); c++; } return c; };
      const rc = (i)=> [Math.floor(i/W), i%W];
      function computeCovered(roads) {
        let coveredMask = 0n;
        for (let i=0;i<N;i++) if (has(roads,i)) {
          const ns = allNeigh[i];
          for (let k=0;k<ns.length;k++) coveredMask |= bit(ns[k]);
        }
        return coveredMask;
      }
      function frontier(roads) {
        let F = 0n;
        for (let i=0;i<N;i++) if (has(roads,i)) {
          const ns = allNeigh[i];
          for (let k=0;k<ns.length;k++) { const v = ns[k]; if (!has(roads, v)) F |= bit(v); }
        }
        return F;
      }
      function kGain(cell, coveredMask) {
        const ns = allNeigh[cell];
        let k=0;
        for (let t=0;t<ns.length;t++) if ((coveredMask & bit(ns[t]))===0n) k++;
        return k-1;
      }
      function has2x2Block(roads, newCell) {
        const [r, c] = rc(newCell);
        // Check all possible 2x2 squares that include this cell
        for (let dr = 0; dr <= 1; dr++) {
          for (let dc = 0; dc <= 1; dc++) {
            const tr = r - dr, tc = c - dc;
            if (tr >= 0 && tc >= 0 && tr + 1 < H && tc + 1 < W) {
              // Check if all 4 cells in this 2x2 square would be roads
              const cells = [
                tr * W + tc, tr * W + (tc + 1),
                (tr + 1) * W + tc, (tr + 1) * W + (tc + 1)
              ];
              let roadCount = 0;
              for (const cellId of cells) {
                if (has(roads, cellId) || cellId === newCell) roadCount++;
              }
              if (roadCount === 4) return true;
            }
          }
        }
        return false;
      }
      function applyAdd(roads, coveredMask, cell) {
        let newRoads = add(roads, cell);
        let newCovered = coveredMask;
        const ns = allNeigh[cell];
        for (let t=0;t<ns.length;t++) newCovered |= bit(ns[t]);
        return [newRoads, newCovered];
      }
      function houses(roads, covered){ return popcnt((covered & ~roads)); }

      let cancelled = false;
      onmessage = (e)=>{
        const msg = e.data;
        if (msg?.cmd === 'cancel') { cancelled = true; return; }
        if (msg?.cmd === 'solve') {
          cancelled = false;
          W=msg.W; H=msg.H; N=W*H; allNeigh = msg.allNeigh;
          let roads = BigInt(msg.roads);
          let covered = BigInt(msg.covered);
          let bestH = houses(roads, covered), bestRoads = roads, bestCovered = covered;
          let bestRoadLen = popcnt(roads);
          let bestObj = bestH - 0.2 * bestRoadLen; // Initial weighted objective
          let nodes = 0;
          const start = Date.now();
          const Ntot = N;

          // Seeded UB: trivial N - |R|, but good ordering + seed from heuristic
          if (msg.seedH !== undefined && msg.seedH > bestH) bestH = msg.seedH;

          const memo = new Map(); // roads -> best houses seen
          const stack = [];
          // initial candidates (symmetry break for square: first step only right)
          let F0 = frontier(roads);
          let cands0 = [];
          for (let i=0;i<N;i++) if ((F0 & bit(i))!==0n) cands0.push(i);
          if (W===H) { // symmetry cut (right preferred over down)
            const right = (1); // (0,1)
            const down  = (W); // (1,0)
            cands0 = cands0.filter(i => i===right || i!==down);
          }
          // push root (no move yet) ‚Äî we will expand from loop by generating children of current roads set
          stack.push({roads, covered, iter: false, cands: cands0, index: 0});

          function ub_trivial(roads) { return Ntot - popcnt(roads); }

          function orderCands(roads, covered, list) {
            // sort by delta desc, then closer to center
            const center = [Math.floor(H/2), Math.floor(W/2)];
            list.sort((a,b)=> {
              const da = kGain(a, covered), db = kGain(b, covered);
              if (db !== da) return db - da;
              const ra = Math.abs(Math.floor(a/W)-center[0]) + Math.abs(a%W-center[1]);
              const rb = Math.abs(Math.floor(b/W)-center[0]) + Math.abs(b%W-center[1]);
              return ra - rb;
            });
            // small cutoff: keep top 16 moves for branching control if huge frontier
            if (list.length > 16) list.length = 16;
            return list;
          }

          let lastPing = start;

          while (stack.length && !cancelled) {
            const node = stack.pop();
            nodes++;

            const curH = houses(node.roads, node.covered);
            const curRoadLen = popcnt(node.roads);
            const curObj = curH - 0.2 * curRoadLen; // Weighted objective: houses - 0.2 * roadLength
            if (curObj > bestObj) { 
              bestH = curH; 
              bestRoadLen = curRoadLen;
              bestObj = curObj;
              bestRoads = node.roads; 
              bestCovered = node.covered; 
            }

            // Upper bound prune (weighted objective)
            const ubHouses = curH + (ub_trivial(node.roads) - curH); // == N - |R|
            const ubRoadLen = popcnt(node.roads); // Current road length (won't decrease)
            const ubObj = ubHouses - 0.2 * ubRoadLen; // Upper bound for weighted objective
            if (ubObj <= bestObj) {
              // ping occasionally
              const now = Date.now(); if (now - lastPing > 250) {
                postMessage({type:'progress', nodes, bestH, bestObj: bestObj.toFixed(1), bestRoadLen, bestRoads: bestRoads.toString(), bestCovered: bestCovered.toString()});
                lastPing = now;
              }
              continue;
            }

            const key = node.roads.toString();
            const prev = memo.get(key);
            if (prev !== undefined && prev >= curH) {
              const now = Date.now(); if (now - lastPing > 250) {
                postMessage({type:'progress', nodes, bestH, bestObj: bestObj.toFixed(1), bestRoadLen, bestRoads: bestRoads.toString(), bestCovered: bestCovered.toString()});
                lastPing = now;
              }
              continue;
            }
            memo.set(key, curH);

            // expand
            let F = frontier(node.roads);
            if (F === 0n) {
              const now = Date.now(); if (now - lastPing > 250) {
                postMessage({type:'progress', nodes, bestH, bestObj: bestObj.toFixed(1), bestRoadLen, bestRoads: bestRoads.toString(), bestCovered: bestCovered.toString()});
                lastPing = now;
              }
              continue;
            }
            const cand = [];
            for (let i=0;i<N;i++) if ((F & bit(i))!==0n) cand.push(i);
            orderCands(node.roads, node.covered, cand);

            // push children
            for (let j=0;j<cand.length;j++) {
              const v = cand[j];
              // Skip if adding this cell would create a 2x2 block of roads
              if (has2x2Block(node.roads, v)) continue;
              const [nr, nc] = applyAdd(node.roads, node.covered, v);
              stack.push({roads: nr, covered: nc});
            }

            const now = Date.now();
            if (now - lastPing > 250) {
              postMessage({type:'progress', nodes, bestH, bestObj: bestObj.toFixed(1), bestRoadLen, bestRoads: bestRoads.toString(), bestCovered: bestCovered.toString()});
              lastPing = now;
            }
          }

          if (cancelled) {
            postMessage({type:'cancelled', nodes, bestH, bestObj: bestObj.toFixed(1), bestRoadLen, bestRoads: bestRoads.toString(), bestCovered: bestCovered.toString()});
          } else {
            postMessage({type:'done', nodes, bestH, bestObj: bestObj.toFixed(1), bestRoadLen, bestRoads: bestRoads.toString(), bestCovered: bestCovered.toString(), ms: Date.now()-start});
          }
        }
      };
    `;
    const blob = new Blob([code], {type: 'application/javascript'});
    const url = URL.createObjectURL(blob);
    exactWorker = new Worker(url);

    exactWorker.onmessage = (e) => {
      const data = e.data;
      if (data.type === 'progress') {
        progressEl.textContent = `Searching‚Ä¶ nodes: ${data.nodes}, houses: ${data.bestH}, road: ${data.bestRoadLen}, obj: ${data.bestObj}`;
        tryUpdateFromWorker(data.bestRoads, data.bestCovered);
      } else if (data.type === 'done') {
        progressEl.textContent = `Done. Explored ${data.nodes} states in ${data.ms} ms. Houses: ${data.bestH}, road: ${data.bestRoadLen}, obj: ${data.bestObj}`;
        tryUpdateFromWorker(data.bestRoads, data.bestCovered, true);
        URL.revokeObjectURL(url);
        setSolverButtons(false, false); // no solvers running
      } else if (data.type === 'cancelled') {
        progressEl.textContent = `Stopped. Houses: ${data.bestH}, road: ${data.bestRoadLen}, obj: ${data.bestObj}, nodes: ${data.nodes}`;
        tryUpdateFromWorker(data.bestRoads, data.bestCovered);
        URL.revokeObjectURL(url);
        setSolverButtons(false, false); // no solvers running
      }
    };

    // bootstrap
    const payload = {
      cmd: 'solve',
      W, H, allNeigh,
      roads: state.roads.toString(),
      covered: state.coveredMask.toString(),
      seedH: popcnt((state.coveredMask & ~state.roads)),
    };
    exactWorker.postMessage(payload);
  }
  function stopExactSolver() {
    if (exactWorker) { exactWorker.postMessage({cmd:'cancel'}); exactWorker.terminate(); exactWorker = null; }
    setSolverButtons(false, false); // no solvers running
  }
  function tryUpdateFromWorker(roadsStr, coveredStr, final=false) {
    // Update board from worker‚Äôs best
    const roads = BigInt(roadsStr), covered = BigInt(coveredStr);
    state.roads = roads; state.coveredMask = covered;
    render();
  }

  // ========= UI =========
  const gridEl = document.getElementById('grid');
  const housesEl = document.getElementById('housesCount');
  const roadEl   = document.getElementById('roadLen');
  const coverEl  = document.getElementById('coverPct');
  const progressEl = document.getElementById('progress');


  const state = { roads: 0n, coveredMask: 0n };
  let cells = [];

  // SVG road sprites definitions
  const roadSprites = `
    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
      <defs>
        <style>
          .edge { fill:none; stroke:#666666; stroke-width:28; stroke-linecap:butt; }
          .road { fill:none; stroke:#2b2b2b; stroke-width:26; stroke-linecap:butt; }
          .mark { fill:none; stroke:#ffffff; stroke-width:2; stroke-linecap:butt; stroke-dasharray:2 2; }
        </style>

        <!-- Straight: horizontal -->
        <g id="straight-h">
          <path class="edge" d="M0,22 H44"/>
          <path class="road" d="M0,22 H44"/>
          <path class="mark" d="M0,22 H44"/>
        </g>

        <!-- Straight: vertical -->
        <g id="straight-v">
          <path class="edge" d="M22,0 V44"/>
          <path class="road" d="M22,0 V44"/>
          <path class="mark" d="M22,0 V44"/>
        </g>

        <!-- Curve from north to east -->
        <g id="curve-ne">
          <path class="edge" d="M22,0 A22,22 0 0 0 44,22"/>
          <path class="road" d="M22,0 A22,22 0 0 0 44,22"/>
          <path class="mark" d="M22,0 A22,22 0 0 0 44,22"/>
        </g>
        
        <!-- Curve from east to south -->
        <g id="curve-es">
          <path class="edge" d="M44,22 A22,22 0 0 0 22,44"/>
          <path class="road" d="M44,22 A22,22 0 0 0 22,44"/>
          <path class="mark" d="M44,22 A22,22 0 0 0 22,44"/>
        </g>
        
        <!-- Curve from south to west -->
        <g id="curve-sw">
          <path class="edge" d="M22,44 A22,22 0 0 0 0,22"/>
          <path class="road" d="M22,44 A22,22 0 0 0 0,22"/>
          <path class="mark" d="M22,44 A22,22 0 0 0 0,22"/>
        </g>
        
        <!-- Curve from west to north -->
        <g id="curve-wn">
          <path class="edge" d="M0,22 A22,22 0 0 0 22,0"/>
          <path class="road" d="M0,22 A22,22 0 0 0 22,0"/>
          <path class="mark" d="M0,22 A22,22 0 0 0 22,0"/>
        </g>

        <!-- CROSS (4-way intersection) -->
        <g id="cross">
          <path class="edge" d="M22,0 V44 M0,22 H44"/>
          <path class="road" d="M22,0 V44 M0,22 H44"/>
          <path class="mark" d="M22,0 V44 M0,22 H44"/>
        </g>

        <!-- T with missing south (‚î¥ shape) -->
        <g id="tee-n">
          <path class="edge" d="M22,0 V22 M0,22 H44"/>
          <path class="road" d="M22,0 V22 M0,22 H44"/>
          <path class="mark" d="M22,0 V22 M0,22 H44"/>
        </g>

        <!-- T with missing west (‚îú shape) -->
        <g id="tee-e">
          <path class="edge" d="M22,0 V44 M22,22 H44"/>
          <path class="road" d="M22,0 V44 M22,22 H44"/>
          <path class="mark" d="M22,0 V44 M22,22 H44"/>
        </g>

        <!-- T with missing north (‚î¨ shape) -->
        <g id="tee-s">
          <path class="edge" d="M22,22 V44 M0,22 H44"/>
          <path class="road" d="M22,22 V44 M0,22 H44"/>
          <path class="mark" d="M22,24 V44 M0,22 H44"/>
        </g>

        <!-- T with missing east (‚î§ shape) -->
        <g id="tee-w">
          <path class="edge" d="M22,0 V44 M0,22 H22"/>
          <path class="road" d="M22,0 V44 M0,22 H22"/>
          <path class="mark" d="M22,0 V44 M0,22 H22"/>
        </g>

        <!-- Dead ends -->
        <g id="deadend-n">
          <path class="edge" d="M22,0 V42"/>
          <path class="road" d="M22,0 V40"/>
          <path class="mark" d="M22,0 V36"/>
        </g>
        
        <g id="deadend-e">
          <path class="edge" d="M44,22 H2"/>
          <path class="road" d="M44,22 H4"/>
          <path class="mark" d="M42,22 H10"/>
        </g>
        
        <g id="deadend-s">
          <path class="edge" d="M22,44 V2"/>
          <path class="road" d="M22,44 V4"/>
          <path class="mark" d="M22,42 V8"/>
        </g>
        
        <g id="deadend-w">
          <path class="edge" d="M0,22 H42"/>
          <path class="road" d="M0,22 H40"/>
          <path class="mark" d="M0,22 H30"/>
        </g>
      </defs>
    </svg>
  `;

  // Create road SVG using sprites
  function createRoadSVG(r, c) {
    const idx = id(r, c);
    // For cell (0,0), always create SVG even if not in roads state
    if (!has(state.roads, idx) && !(r === 0 && c === 0)) return null;
    
    // Check connections to neighbors (up, right, down, left)
    const up = (r > 0) && has(state.roads, id(r-1, c));
    const right = (c < W-1) && has(state.roads, id(r, c+1));
    const down = (r < H-1) && has(state.roads, id(r+1, c));
    // For cell (0,0), assume there's a road to the left at (-1,0)
    const left = (c > 0) && has(state.roads, id(r, c-1)) || (r === 0 && c === 0);
    
    let spriteId = '';
    
    // Count connections
    const connections = [up, right, down, left];
    const count = connections.filter(Boolean).length;
    
    if (count === 1) {
      // Dead ends
      if (up) spriteId = 'deadend-n';
      else if (right) spriteId = 'deadend-e';  
      else if (down) spriteId = 'deadend-s';
      else if (left) spriteId = 'deadend-w';
    } else if (count === 2) {
      // Straight lines or corners
      if (up && down) spriteId = 'straight-v';
      else if (left && right) spriteId = 'straight-h';
      else if (up && right) spriteId = 'curve-ne';
      else if (right && down) spriteId = 'curve-es';
      else if (down && left) spriteId = 'curve-sw';
      else if (left && up) spriteId = 'curve-wn';
    } else if (count === 3) {
      // T-junctions
      if (!up) spriteId = 'tee-s';     // T pointing down (missing up)
      else if (!right) spriteId = 'tee-w';  // T pointing left (missing right)
      else if (!down) spriteId = 'tee-n';   // T pointing up (missing down)
      else if (!left) spriteId = 'tee-e';   // T pointing right (missing left)
    } else if (count === 4) {
      // Cross intersection
      spriteId = 'cross';
    }
    
    if (!spriteId) return null;
    
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', '100%');
    svg.setAttribute('height', '100%');
    svg.setAttribute('viewBox', '0 0 44 44');
    svg.style.position = 'absolute';
    svg.style.top = '0';
    svg.style.left = '0';
    
    const use = document.createElementNS('http://www.w3.org/2000/svg', 'use');
    use.setAttributeNS('http://www.w3.org/1999/xlink', 'href', `#${spriteId}`);
    svg.appendChild(use);
    
    return svg;
  }

  function initRoadSprites() {
    // Add road sprites to DOM if not already present
    if (!document.getElementById('road-sprites')) {
      const container = document.createElement('div');
      container.id = 'road-sprites';
      container.innerHTML = roadSprites;
      document.body.appendChild(container);
    }
  }

  function buildGrid() {
    gridEl.innerHTML = '';
    gridEl.style.gridTemplateColumns = `repeat(${W}, var(--cell))`;
    gridEl.style.gridTemplateRows = `repeat(${H}, var(--cell))`;
    cells = [];
    for (let r=0;r<H;r++) {
      for (let c=0;c<W;c++) {
        const el = document.createElement('div');
        el.className = 'cell';
        const coord = document.createElement('div');
        coord.className = 'coord';
        coord.textContent = `${r},${c}`;
        const ov = document.createElement('div');
        ov.className = 'covered';
        el.append(coord, ov);
        
        // Add click handler for manual road drawing
        el.addEventListener('click', () => handleCellClick(r, c));
        
        gridEl.appendChild(el);
        cells.push(el);
      }
    }
  }
  function initBoard() {
    state.roads = 0n; state.coveredMask = 0n;
    // start at (0,0)
    const s = 0;
    state.roads = add(0n, s);
    const ns = allNeigh[s];
    for (let k=0;k<ns.length;k++) state.coveredMask |= bit(ns[k]);
    render();
    progressEl.textContent = 'Ready.';
    // Initially no solvers running
    setSolverButtons(false, false);
  }
  function render() {
    const housesMask = state.coveredMask & ~state.roads;
    for (let i=0;i<N;i++) {
      const el = cells[i];
      const [r, c] = rc(i);
      const isRoad = has(state.roads, i);
      const isAdjacent = isAdjacentToRoad(r, c);
      const canRemove = isRoad && !wouldDisconnectRoad(i) && !(r === 0 && c === 0);
      
      // For cell (0,0), always apply road class
      el.classList.toggle('road', isRoad || (r === 0 && c === 0));
      // For cell (0,0), never apply house class (it's always road)
      el.classList.toggle('house', (!isRoad && (housesMask & bit(i))!==0n && !(r === 0 && c === 0)));
      el.classList.toggle('covered-on', ((state.coveredMask & bit(i))!==0n));
      
      // Visual hints for clickable cells
      el.classList.toggle('clickable-add', !isRoad && isAdjacent);
      el.classList.toggle('clickable-remove', canRemove);
      
      // Set road SVG element
      // Clear any existing SVG elements first
      const existingSvg = el.querySelector('svg');
      if (existingSvg) {
        existingSvg.remove();
      }
      
      // For cell (0,0), always show road SVG even if not in roads state
      if (isRoad || (r === 0 && c === 0)) {
        const roadSvg = createRoadSVG(r, c);
        if (roadSvg) {
          el.appendChild(roadSvg);
        }
      }
    }
    const houses = popcnt(housesMask);
    const roadLen = popcnt(state.roads);
    const coveredCount = popcnt(state.coveredMask | state.roads);
    housesEl.textContent = houses;
    roadEl.textContent = roadLen;
    coverEl.textContent = Math.round(coveredCount * 100 / N) + '%';
  }

  // Check if a cell is adjacent to existing road (4-connected)
  function isAdjacentToRoad(r, c) {
    const cellIndex = id(r, c);
    const neighbors = allNeigh[cellIndex];
    for (const neighbor of neighbors) {
      if (has(state.roads, neighbor)) {
        return true;
      }
    }
    return false;
  }

  // Check if removing a road cell would disconnect the road
  function wouldDisconnectRoad(cellIndex) {
    if (!has(state.roads, cellIndex)) return false;
    
    // If it's the only road cell, removing it would disconnect
    if (popcnt(state.roads) === 1) return true;
    
    // Create temporary road without this cell
    const tempRoads = state.roads & ~bit(cellIndex);
    
    // Check if remaining road is connected using BFS
    let visitedMask = 0n;
    const queue = [];
    
    // Find first remaining road cell as starting point
    let startCell = -1;
    for (let i = 0; i < N; i++) {
      if (has(tempRoads, i)) {
        startCell = i;
        break;
      }
    }
    
    if (startCell === -1) return true; // No remaining road cells
    
    queue.push(startCell);
    visitedMask = add(visitedMask, startCell);
    
    while (queue.length > 0) {
      const current = queue.shift();
      const neighbors = allNeigh[current];
      
      for (const neighbor of neighbors) {
        if (has(tempRoads, neighbor) && !has(visitedMask, neighbor)) {
          visitedMask = add(visitedMask, neighbor);
          queue.push(neighbor);
        }
      }
    }
    
    // If not all road cells were visited, the road would be disconnected
    return visitedMask !== tempRoads;
  }

  function handleCellClick(r, c) {
    const cellIndex = id(r, c);
    const isRoad = has(state.roads, cellIndex);
    
    if (isRoad) {
      // Cannot remove starting cell (0,0)
      if (r === 0 && c === 0) {
        progressEl.textContent = 'Cannot remove starting road cell (0,0).';
        return;
      }
      
      // Try to remove road cell if it doesn't disconnect the road
      if (!wouldDisconnectRoad(cellIndex)) {
        state.roads = state.roads & ~bit(cellIndex);
        const result = computeCovered(state.roads);
        state.coveredMask = result.coveredMask;
        render();
        progressEl.textContent = 'Road cell removed manually.';
      } else {
        progressEl.textContent = 'Cannot remove: would disconnect road.';
      }
    } else {
      // Try to add road cell if adjacent to existing road
      if (isAdjacentToRoad(r, c)) {
        state.roads = add(state.roads, cellIndex);
        const result = computeCovered(state.roads);
        state.coveredMask = result.coveredMask;
        render();
        progressEl.textContent = 'Road cell added manually.';
      } else {
        progressEl.textContent = 'Can only add road to adjacent cells.';
      }
    }
  }

  // ========= Wire controls =========
  document.getElementById('resize').addEventListener('click', () => {
    // Stop any running solvers before reset
    stopHeuristicSolver();
    stopExactSolver();
    
    const nw = Math.max(2, Math.min(15, +document.getElementById('w').value|0));
    const nh = Math.max(2, Math.min(15, +document.getElementById('h').value|0));
    W = nw; H = nh;
    buildNeigh();
    buildGrid();
    initBoard();
  });

  document.getElementById('solveHeuristic').addEventListener('click', () => {
    progressEl.textContent = 'Starting heuristic search‚Ä¶';
    startHeuristicSolver(state.roads, state.coveredMask, {beam: 40, restarts: 8, lookahead: 5});
  });

  document.getElementById('stopHeuristic').addEventListener('click', () => {
    stopHeuristicSolver();
  });

  document.getElementById('solveExact').addEventListener('click', () => {
    progressEl.textContent = 'Starting optimal search‚Ä¶';
    startExactSolver(state.roads, state.coveredMask);
  });
  document.getElementById('stopExact').addEventListener('click', () => {
    stopExactSolver();
  });


  // bootstrap
  initRoadSprites();
  buildNeigh();
  buildGrid();
  initBoard();
})();
</script>
</body>
</html>
